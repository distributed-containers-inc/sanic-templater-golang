package main

import (
	"fmt"
	"html/template"
	"os"
	"path/filepath"
	"strings"
	"syscall"
)

func wipeOutputDiretory() error {
	files, err := filepath.Glob("/out/*.yaml") //TODO json too?
	if err != nil {
		return err
	}
	for _, f := range files {
		err = os.Remove(f)
		if err != nil {
			return err
		}
	}
	return nil
}

func getenv(key string, default_ ...string) string {
	env := os.Getenv(key)
	if env != "" {
		return env
	}
	return strings.Join(default_, " ")
}

func main() {
	files, err := filepath.Glob("/in/*.tmpl")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Could not find the template files at /in, expecting, e.g., /in/a.tmpl, /in/b.tmpl to exist. Error: %s\n", err.Error())
		syscall.Exit(1)
	}
	if len(files) == 0 {
		fmt.Fprintf(os.Stderr, "No configuration files were specified at /in/... with suffix '.tmpl'\n")
		syscall.Exit(1)
	}

	err = wipeOutputDiretory()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Could not delete the contents of the output directory. Is it mounted read/write? %s\n", err.Error())
		syscall.Exit(1)
	}

	fmt.Printf("Templating %d config files...\n", len(files))

	for _, templatepath := range files {
		templateName := strings.TrimSuffix(filepath.Base(templatepath), ".tmpl")
		fmt.Printf("Running template %s...\n", templateName)
		t, err := template.New(
			filepath.Base(templatepath),
		).Funcs(
			map[string]interface{}{
				"getenv": getenv,
			},
		).ParseFiles(
			append([]string{templatepath}, files...)...
		)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Could not compile the templates at /in/...: %s\n", err.Error())
			syscall.Exit(1)
		}

		//400: not writable by user intentionally, these files are auto generated
		outFile, err := os.OpenFile("/out/"+templateName, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Could not open the file at /out/%s for writing. Did you run this image with -v (output path on host):/out ?\n", templateName)
			syscall.Exit(1)
		}
		outFile.WriteString("#WARNING: THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT IT DIRECTLY OR COMMIT IT\n")

		err = t.Execute(outFile, nil)
		outFile.Close()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Could not execute the template at %s: %s\n", templatepath, err.Error())
			syscall.Exit(1)
		}
		err = os.Chown("/out/"+templateName, 1001, 1001)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Could not chown the template %s to %d/%d", templateName, 1001, 1001)
		}
	}

}
